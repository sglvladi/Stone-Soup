#!/usr/bin/env python
# coding: utf-8

# # Single Rotating Radar Simulation & Single-Target Tracking
# 
# This script demonstrates a simulation of a single 2-D (Range-Bearing) Radar, which is mounted on a non-stationary platform and generates measurements of a single (also non-stationary) ground truth target. 
# 
# Additionally, an EKF and UKF Predictor/Updater pairs are employed to estimate the state of the ground truth target, given the measurements generated by the radar.

# In[1]:


# Import external dependencies
import numpy as np
from copy import copy
from datetime import datetime, timedelta
from scipy.optimize import linear_sum_assignment

# Import from Stone Soup
from stonesoup.types.hypothesis import SingleHypothesis
from stonesoup.types.detection import Detection
from stonesoup.types.state import State, GaussianState
from stonesoup.types.track import Track
from stonesoup.types.array import StateVector, CovarianceMatrix
from stonesoup.types.angle import Bearing
from stonesoup.functions import pol2cart
from stonesoup.models.transition.linear import (
    ConstantVelocity,
    ConstantTurn,
    CombinedLinearGaussianTransitionModel
)
from stonesoup.platform.simple import SensorPlatform
from stonesoup.sensor.radar import RadarRotatingRangeBearing
from stonesoup.sensor.sonar import SonarJustBearing
from stonesoup.simulator.simple import SingleTargetGroundTruthSimulator
from stonesoup.predictor.kalman import (
    ExtendedKalmanPredictor,
    UnscentedKalmanPredictor
)
from stonesoup.updater.kalman import (
    ExtendedKalmanUpdater,
    UnscentedKalmanUpdater
)
from stonesoup.metricgenerator.ospametric import OSPAMetric

# Plotting
from matplotlib.patches import Ellipse
from matplotlib import pyplot as plt

###############################################################################
# Plotting functions                                                          #
###############################################################################

plt.rcParams['figure.figsize'] = (12, 8)
plt.style.use('seaborn-colorblind')
fig = plt.figure()


def plot_cov_ellipse(cov, pos, nstd=2, ax=None, **kwargs):
    """
    Plots an `nstd` sigma error ellipse based on the specified covariance
    matrix (`cov`). Additional keyword arguments are passed on to the
    ellipse patch artist.
    Parameters
    ----------
        cov : The 2x2 covariance matrix to base the ellipse on
        pos : The location of the center of the ellipse. Expects a 2-element
            sequence of [x0, y0].
        nstd : The radius of the ellipse in numbers of standard deviations.
            Defaults to 2 standard deviations.
        ax : The axis that the ellipse will be plotted on. Defaults to the
            current axis.
        Additional keyword arguments are pass on to the ellipse patch.
    Returns
    -------
        A matplotlib ellipse artist
    """

    def eigsorted(cov):
        vals, vecs = np.linalg.eigh(cov)
        order = vals.argsort()[::-1]
        return vals[order], vecs[:, order]

    if ax is None:
        ax = plt.gca()

    vals, vecs = eigsorted(cov)
    theta = np.degrees(np.arctan2(*vecs[:, 0][::-1]))

    # Width and height are "full" widths, not radius
    width, height = 2 * nstd * np.sqrt(vals)
    ellip = Ellipse(xy=pos, width=width, height=height, angle=theta, **kwargs)

    ax.add_artist(ellip)
    return ellip


def plot_groundtruth(groundtruth_paths, timestamp):
    # Plot GroundTruth tracks
    for path in groundtruth_paths:
        data = np.array([state.state_vector for state in path
                         if state.timestamp <= timestamp])
        plt.plot(data[:, 0],
                 data[:, 2], linestyle='-', marker='')


def plot_detections(detections, timestamp):
    # Plot the detections

    ## RADAR
    # data = []
    # for detection in detections:
    #     if detection is not None and detection.timestamp == timestamp:
    #         # Transform back to global co-ordinate frame for plotting
    #         rot_mat = detection.measurement_model._rotation_matrix
    #         cart = np.linalg.pinv(rot_mat[0:2, 0:2]) \
    #                @ pol2cart(detection.state_vector[1, 0],
    #                           detection.state_vector[0, 0]) \
    #                + detection.measurement_model.translation_offset[0:2, 0]
    #         xy = StateVector(cart.reshape((2, 1)))
    #         data.append(xy)
    # data = np.array(data)[:, :, 0].T
    # if (data.shape[0] > 0):
    #     plt.plot(data[0, :], data[1, :], linestyle='', marker='2')

    ## SONAR
    for detection in detections:
        if detection is not None and detection.timestamp==timestamp:
            origin = detection.measurement_model.translation_offset
            orientation = detection.measurement_model.rotation_offset[2,0]
            [x, y] = pol2cart(100, orientation+detection.state_vector[0,0])
            plt.quiver(*origin, x, y, color=['r', 'b', 'g'], scale=1, width=0.001)


def plot_platforms(platforms, radar_positions, radar_orientations, timestamp):
    for i, platform in enumerate(platforms):
        # Plot the platform position
        data = np.array([state.state_vector
                         for state in platform
                         if state.timestamp <= timestamp])
        plt.plot(data[:, 0], data[:, 2],
                 linestyle='-', marker='.')

        # Plot the sensor FOV (RADAR)
        # origin = [position.state_vector
        #           for position in radar_positions[i]
        #           if position.timestamp <= timestamp][-1]
        # orientation = [orientation.state_vector
        #                for orientation in radar_orientations[i]
        #                if orientation.timestamp <= timestamp][-1]
        # fov = radar.fov_angle
        # fov_min = orientation[0, 0] - fov / 2
        # fov_max = orientation[0,0] + fov / 2
        # [x, y] = pol2cart(100, fov_min)
        # plt.quiver(*origin, x, y, color=['r', 'b', 'g'], scale=1, width=0.001)
        # [x, y] = pol2cart(100, fov_max)
        # plt.quiver(*origin, x, y, color=['r', 'b', 'g'], scale=1, width=0.001)


def plot_data(timestamp, groundtruth_paths, detections, tracks,
              platforms, radar_positions, radar_orientations,
              radar, frame_index=None):
    plt.clf()
    plt.rcParams['figure.figsize'] = (8, 8)
    plt.style.use('seaborn-colorblind')

    # Plot GroundTruth tracks
    plot_groundtruth(groundtruth_paths, timestamp)

    # Plot the platform trajectories
    plot_platforms(platforms, radar_positions, radar_orientations, timestamp)

    # Plot the detections
    plot_detections(detections, timestamp)

    # Plot the estimated trajectory
    for track in tracks:
        data = np.array([state.state_vector for state in track.states])
        if (data.shape[0] > 0):
            plt.plot(data[:frame_index + 1, 0],
                     data[:frame_index + 1, 2], linestyle='-', color='m')
            plot_cov_ellipse(track.covar[[0, 2], :][:, [0, 2]],
                             track.mean[[0, 2], :], edgecolor='r',
                             facecolor='none')

    plt.axis('equal')
    plt.xlabel("$x$")
    plt.ylabel("$y$")
    plt.legend(['Ground Truth', 'Platform/Sensor Trajectory',
                'Detections', 'Estimated Trajectory'])
    plt.pause(0.1)


###############################################################################
# Generic/Global config                                                       #
###############################################################################

NUM_PLATFORMS = 4  # Number of platforms to simulate
NUM_SIM_STEPS = 100  # Number of simulation timesteps
STEP_DURATION = timedelta(seconds=0.05)  # Time step duration
INIT_TIMESTAMP = datetime.now()  # Time of simulation start

###############################################################################
# Simulation                                                                  #
###############################################################################

# Add Target GroundTruth Simulator
# --------------------------------------------------

# In[2]:


# Set up target's transition model
target_transition_model = CombinedLinearGaussianTransitionModel(
    (ConstantVelocity(1), ConstantVelocity(1)))

# Set target ground truth prior
ground_truth_prior_state_vector = StateVector(
    [
        [np.random.rand() * 100 - 50],
        [np.random.rand() * 10 - 5],
        [np.random.rand() * 100 - 50],
        [np.random.rand() * 10 - 5]
    ]
)
ground_truth_prior = GaussianState(
    ground_truth_prior_state_vector,
    CovarianceMatrix(np.diag([10, 1, 10, 1])),
    timestamp=INIT_TIMESTAMP
)

# Generate a single target ground truth simulator
groundtruth_sim = SingleTargetGroundTruthSimulator(
    transition_model=target_transition_model,
    initial_state=ground_truth_prior,
    timestep=STEP_DURATION,
    number_steps=NUM_SIM_STEPS
)
# Create ground truth generator function
gts = groundtruth_sim.groundtruth_paths_gen()

# Setup a Radar sensor
# -------------------------------

# In[3]:


# Generate a radar sensor
noise_covar = CovarianceMatrix(np.array([[0.001, 0],
                                         [0, 1]]))
# Set the radar position and orientation
# (dummy, since they will be overwitten when attached to platform)
radar_position = StateVector(np.array([[0], [0]]))
radar_orientation = StateVector(np.array([[0], [0], [0]]))

# Set the dwell offset of the radar head relative to the orientation
# of the sensors
dwell_center = State(StateVector([[0]]), copy(INIT_TIMESTAMP))

# Instantiate the rotating radar
radar = RadarRotatingRangeBearing(radar_position,
                                  radar_orientation,
                                  ndim_state=4,
                                  mapping=np.array([0, 2]),
                                  noise_covar=noise_covar,
                                  dwell_center=dwell_center,
                                  rpm=20,
                                  max_range=100000,
                                  fov_angle=np.pi * 2)

sonar = SonarJustBearing(radar_position,
                         radar_orientation,
                         ndim_state=4,
                         mapping=np.array([0, 2]),
                         noise_covar=CovarianceMatrix([[0.001]]))

# Add a Platforms and attach the sensors on them
# ------------------------------------------------------------

# In[4]:

# Define transition model and position for 2D platform
# platform_transition_model = CombinedLinearGaussianTransitionModel(
#     [ConstantVelocity(1), ConstantVelocity(1)])
platform_transition_model = ConstantTurn([0.001, 0.001], 0.1)

# Define a mounting offset for a sensor relative to the platform
mounting_offsets = np.array([[0, 0], [0, 0]])
# This defines the mapping to the platforms state vector (i.e. x and y)
mounting_mappings = np.array([[0, 2]])

platforms = []
for i in range(NUM_PLATFORMS):
    # Initial platform state
    platform_prior_state_vector = StateVector(
        [
            [np.random.rand() * 100 - 50],
            [np.random.rand() * 10 - 5],
            [np.random.rand() * 100 - 50],
            [np.random.rand() * 10 - 5]
        ]
    )
    platform_state = State(platform_prior_state_vector, INIT_TIMESTAMP)
    # create a platform with a radar and sonar sensors mounted
    platform = SensorPlatform(copy(platform_state),
                              platform_transition_model,
                              sensors=[copy(radar), copy(sonar)],
                              mounting_offsets=mounting_offsets,
                              mounting_mappings=mounting_mappings)
    platforms.append(copy(platform))

# Run Simulation
# ------------------------------------------------------------

# In[5]:

groundtruth_paths = set()  # Store for plotting later
platform_positions = []  # Store platform path
radar_positions = []
radar_orientations = []
for i in range(NUM_PLATFORMS):
    platform_positions.append([])
    radar_positions.append([])
    radar_orientations.append([])
measurement_pol_list = []
measurement_cart_list = []
measurement_sonar = []

# Simulate
timestamp = INIT_TIMESTAMP
for i in range(NUM_SIM_STEPS):

    # Run Ground truth simulator
    next(gts)

    # Generate and extract ground truth state
    groundtruth_paths |= groundtruth_sim.groundtruth_paths
    target_state = groundtruth_sim.groundtruth_paths.pop()[-1]

    # Move platform
    for j, platform in enumerate(platforms):
        platform.move(timestamp)

        # Store position and oritentation of platform/sensor(s)
        platform_positions[j].append(platform.state)
        radar_positions[j].append(State(platform.sensors[0].position,
                                        timestamp))

        # Measure the target location
        measurement_pol = platform.sensors[0].gen_measurement(target_state)
        radar_orientations[j].append(
            State([[platform.sensors[0].dwell_center.state_vector[0, 0]
                    + platform.sensors[0].orientation[2, 0]]],
                  timestamp))
        measurement_pol_list.append(measurement_pol)
        measurement_sonar.append(
            platform.sensors[1].gen_measurement(target_state))

        if measurement_pol is not None:

            # Transform back to global co-ordinate frame for plotting
            rot_mat = measurement_pol.measurement_model._rotation_matrix
            measurement_cart = np.linalg.pinv(rot_mat[0:2, 0:2]) @ pol2cart(
                measurement_pol.state_vector[1][0],
                measurement_pol.state_vector[0][0])

            measurement_cart_list.append(
                Detection(
                    StateVector(
                        [[measurement_cart[0]
                          +
                          measurement_pol.measurement_model.translation_offset[
                              0][
                              0]],  # noqa:E501
                         [measurement_cart[1]
                          +
                          measurement_pol.measurement_model.translation_offset[
                              1][
                              0]]
                         ]
                    ),
                    timestamp=measurement_pol.timestamp
                )
            )
        else:
            measurement_cart_list.append(None)
    timestamp = timestamp + STEP_DURATION

# # Estimate

# In[ ]:


# Estimate
timestamp = INIT_TIMESTAMP

# Assume we know the target's initial state
state_prior = copy(ground_truth_prior)
track = Track([state_prior])

predictor = UnscentedKalmanPredictor(target_transition_model)
updater = UnscentedKalmanUpdater(measurement_model=sonar.measurement_model)

for i, measurement in enumerate(measurement_sonar):

    # Extract simulated measurement
    timestamp = measurement.timestamp

    # Predict the target position using UKF
    state_prediction = predictor.predict(track[-1],
                                         timestamp=timestamp)

    # If a measurement of the target is received
    if measurement is not None:
        # Update/Correct the target position using UKF
        hypothesis = SingleHypothesis(state_prediction, measurement)
        state_prior = updater.update(hypothesis=hypothesis)
        track.append(state_prior)
    else:
        # Estimate the target position using UKF
        state_prior = state_prediction
        track.append(state_prior)

    # Uncomment code below to plot all frames 
    # (WARNING: It takes a while and eats up RAM space!)
    plot_data(timestamp, groundtruth_paths, measurement_pol_list, [track],
              platform_positions, radar_positions,
              radar_orientations, radar, i)

# # Plot output

# In[ ]:
ospa = OSPAMetric(c=8, p=2, measurement_model_truth=radar.measurement_model,
                  measurement_model_track=radar.measurement_model)

gnd_track = groundtruth_paths.pop()
ospa_metric = ospa.compute_over_time(track.states, gnd_track.states)
ospa_cost_matrix = ospa.compute_cost_matrix(track.states, gnd_track.states)
measured_to_truth, truth_to_measured = linear_sum_assignment(ospa_cost_matrix)

truth_set = np.array([state.state_vector[[[0], [2]], [0]] for state in
                      gnd_track.states])[:, :, 0].T
track_set = np.array([state.state_vector[[[0], [2]], [0]] for state in
                      track.states])[:, :, 0].T
plt.figure()
fig_b = plt.plot(track_set[0,:], track_set[1,:], 'bo-', truth_set[0,:],
                 truth_set[1,:], 'r+-')
truth_ind = truth_to_measured
track_ind = measured_to_truth
for ind in range(len(truth_ind)):
    db = np.min([np.sqrt(sum(np.square(track_set[:,track_ind[ind]] - truth_set[:,truth_ind[ind]]))), ospa.c])
    if db < 8:
        plt.plot([track_set[0, track_ind[ind]], truth_set[0, truth_ind[ind]]],
                 [track_set[1, track_ind[ind]], truth_set[1, truth_ind[ind]]],
                 'k-')
        plt.text(track_set[0, track_ind[ind]]/2.+truth_set[0, truth_ind[ind]]/2.,
                 track_set[1, track_ind[ind]]/2.+truth_set[1, truth_ind[ind]]/2.,
                 "{:.2f}".format(db),
                 horizontalalignment='right',
                 verticalalignment='bottom')
# plt.title("OSPA Example [c={}, p={}, OSPA distance={:.2f}]".format(ospa.c, ospa.p, ospa_metric.value))
plt.legend(['Track', 'Truth'])
plt.show()
plt.clf()
plot_data(timestamp, groundtruth_paths, measurement_pol_list, [track],
          platform_positions[0], radar_positions[0],
          radar_orientations[0], radar, i, True)
plt.show()

# In[ ]:
