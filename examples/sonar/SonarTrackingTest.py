#!/usr/bin/env python
# coding: utf-8

# # Single Rotating Radar Simulation & Single-Target Tracking
# 
# This script demonstrates a simulation of a single 2-D (Range-Bearing) Radar, which is mounted on a non-stationary platform and generates measurements of a single (also non-stationary) ground truth target. 
# 
# Additionally, an EKF and UKF Predictor/Updater pairs are employed to estimate the state of the ground truth target, given the measurements generated by the radar.

# In[1]:


# Import external dependencies
import numpy as np
from copy import copy
from datetime import datetime, timedelta
from scipy.optimize import linear_sum_assignment

# Import from Stone Soup
from stonesoup.types.hypothesis import SingleHypothesis
from stonesoup.types.detection import Detection
from stonesoup.types.state import State, GaussianState
from stonesoup.types.track import Track
from stonesoup.types.array import StateVector, CovarianceMatrix
from stonesoup.types.angle import Bearing
from stonesoup.functions import pol2cart
from stonesoup.models.transition.linear import (
    ConstantVelocity,
    ConstantTurn,
    CombinedLinearGaussianTransitionModel
)
from stonesoup.models.measurement.linear import LinearGaussian
from stonesoup.platform.simple import SensorPlatform
from stonesoup.sensor.sonar import SonarJustBearing
from stonesoup.simulator.simple import SingleTargetGroundTruthSimulator
from stonesoup.predictor.kalman import (
    ExtendedKalmanPredictor,
    UnscentedKalmanPredictor
)
from stonesoup.updater.kalman import (
    ExtendedKalmanUpdater,
    UnscentedKalmanUpdater
)
from stonesoup.hypothesiser.distance import DistanceHypothesiser
from stonesoup.dataassociator.neighbour import GlobalNearestNeighbour
from stonesoup.initiator.simple import SinglePointInitiator
from stonesoup.deleter.time import UpdateTimeStepsDeleter
from stonesoup.measures import Mahalanobis
from stonesoup.metricgenerator.ospametric import OSPAMetric, GOSPAMetric

# Plotting
from matplotlib.patches import Ellipse
from matplotlib import pyplot as plt

###############################################################################
# Plotting functions                                                          #
###############################################################################

plt.rcParams['figure.figsize'] = (12, 8)
plt.style.use('seaborn-colorblind')
fig = plt.figure()


def plot_cov_ellipse(cov, pos, nstd=2, ax=None, **kwargs):
    """
    Plots an `nstd` sigma error ellipse based on the specified covariance
    matrix (`cov`). Additional keyword arguments are passed on to the
    ellipse patch artist.
    Parameters
    ----------
        cov : The 2x2 covariance matrix to base the ellipse on
        pos : The location of the center of the ellipse. Expects a 2-element
            sequence of [x0, y0].
        nstd : The radius of the ellipse in numbers of standard deviations.
            Defaults to 2 standard deviations.
        ax : The axis that the ellipse will be plotted on. Defaults to the
            current axis.
        Additional keyword arguments are pass on to the ellipse patch.
    Returns
    -------
        A matplotlib ellipse artist
    """

    def eigsorted(cov):
        vals, vecs = np.linalg.eigh(cov)
        order = vals.argsort()[::-1]
        return vals[order], vecs[:, order]

    if ax is None:
        ax = plt.gca()

    vals, vecs = eigsorted(cov)
    theta = np.degrees(np.arctan2(*vecs[:, 0][::-1]))

    # Width and height are "full" widths, not radius
    width, height = 2 * nstd * np.sqrt(vals)
    ellip = Ellipse(xy=pos, width=width, height=height, angle=theta, **kwargs)

    ax.add_artist(ellip)
    return ellip


def plot_groundtruth(groundtruth_paths, timestamp):
    # Plot GroundTruth tracks
    for path in groundtruth_paths:
        data = np.array([state.state_vector for state in path
                         if state.timestamp <= timestamp])
        plt.plot(data[:, 0],
                 data[:, 2], linestyle='-', marker='.')


def plot_detections(scans, timestamp):
    # Plot the detections
    for t, detections in scans:
        if t == timestamp:
            for detection in detections:
                origin = detection.measurement_model.translation_offset
                orientation = detection.measurement_model.rotation_offset[2,0]
                [x, y] = pol2cart(100, orientation+detection.state_vector[0,0])
                plt.quiver(*origin, x, y, color=['r', 'b', 'g'], scale=1, width=0.001)


def plot_platforms(platforms, sensor_positions, sensor_orientations, timestamp):
    for i, platform in enumerate(platforms):
        # Plot the platform position
        data = np.array([state.state_vector
                         for state in platform
                         if state.timestamp <= timestamp])
        plt.plot(data[:, 0], data[:, 2],
                 linestyle='-', marker='.')


def plot_data(timestamp, groundtruth_paths, detections, tracks,
              platforms, sensor_positions, sensor_orientations,
              radar, frame_index=None):
    plt.clf()
    plt.rcParams['figure.figsize'] = (8, 8)
    plt.style.use('seaborn-colorblind')

    # Plot GroundTruth tracks
    plot_groundtruth(groundtruth_paths, timestamp)

    # Plot the platform trajectories
    plot_platforms(platforms, sensor_positions, sensor_orientations, timestamp)

    # Plot the detections
    plot_detections(detections, timestamp)

    # Plot the estimated trajectory
    for track in tracks:
        data = np.array([state.state_vector for state in track.states
                         if np.trace(state.covar)<10])
        if (data.shape[0] > 0):
            plt.plot(data[:frame_index + 1, 0],
                     data[:frame_index + 1, 2], linestyle='-', color='m')
            plot_cov_ellipse(track.covar[[0, 2], :][:, [0, 2]],
                             track.mean[[0, 2], :], edgecolor='c',
                             facecolor='none')

    plt.axis('equal')
    plt.xlabel("$x$")
    plt.ylabel("$y$")

    legend = []
    for i in range(NUM_TARGETS):
        legend.append('Target {}'.format(i+1))
    for i in range(NUM_PLATFORMS):
        legend.append('Platform {}'.format(i+1))
    legend.append('Tracks')
    plt.legend(legend)
    plt.pause(0.1)


###############################################################################
# Generic/Global config                                                       #
###############################################################################

NUM_TARGETS = 2  # Number of targets
NUM_PLATFORMS = 5  # Number of platforms to simulate
NUM_SIM_STEPS = 100  # Number of simulation timesteps
STEP_DURATION = timedelta(seconds=0.05)  # Time step duration
INIT_TIMESTAMP = datetime.now()  # Time of simulation start
DETECTION_PROBABILITY = 1.0  # Detection probability
CLUTTER_RATE = 0.0  # Clutter rate

###############################################################################
# Simulation                                                                  #
###############################################################################

# Add Target GroundTruth Simulator
# --------------------------------------------------

# In[2]:


# Set up target's transition model
target_transition_model = CombinedLinearGaussianTransitionModel(
    (ConstantVelocity(1), ConstantVelocity(1)))

gnd_simulators = []
gnd_sim_handles = []
#gnd_priors = []

for i in range(NUM_TARGETS):
    # Set target ground truth prior
    ground_truth_prior_state_vector = StateVector(
        [
            [np.random.rand() * 100 - 50],
            [np.random.rand() * 10 - 5],
            [np.random.rand() * 100 - 50],
            [np.random.rand() * 10 - 5]
        ]
    )
    ground_truth_prior = GaussianState(
        ground_truth_prior_state_vector,
        CovarianceMatrix(np.diag([10, 1, 10, 1])),
        timestamp=INIT_TIMESTAMP
    )
    # Generate a single target ground truth simulator
    groundtruth_sim = SingleTargetGroundTruthSimulator(
        transition_model=target_transition_model,
        initial_state=ground_truth_prior,
        timestep=STEP_DURATION,
        number_steps=NUM_SIM_STEPS
    )

    # Append
    gnd_simulators.append(copy(groundtruth_sim))


# Setup a Radar sensor
# -------------------------------

# In[3]:


# Generate a radar sensor
noise_covar = CovarianceMatrix(np.array([[0.001, 0],
                                         [0, 1]]))
# Set the radar position and orientation
# (dummy, since they will be overwritten when attached to platform)
sensor_position = StateVector(np.array([[0], [0]]))
sensor_orientation = StateVector(np.array([[0], [0], [0]]))

sonar = SonarJustBearing(position=sensor_position,
                         orientation=sensor_orientation,
                         ndim_state=4,
                         mapping=np.array([0, 2]),
                         noise_covar=CovarianceMatrix([[0.0001]]),
                         detection_probability=1,
                         clutter_rate=0.0)

# Add a Platforms and attach the sensors on them
# ------------------------------------------------------------

# In[4]:

# Define transition model and position for 2D platform
platform_transition_model = ConstantTurn([0.001, 0.001], 0.1)

# Define a mounting offset for a sensor relative to the platform
mounting_offsets = np.array([[0, 0]])
# This defines the mapping to the platforms state vector (i.e. x and y)
mounting_mappings = np.array([[0, 2]])

platforms = []
for i in range(NUM_PLATFORMS):
    # Initial platform state
    platform_prior_state_vector = StateVector(
        [
            [np.random.rand() * 100 - 50],
            [np.random.rand() * 10 - 5],
            [np.random.rand() * 100 - 50],
            [np.random.rand() * 10 - 5]
        ]
    )
    platform_state = State(platform_prior_state_vector, INIT_TIMESTAMP)
    # create a platform with a radar and sonar sensors mounted
    platform = SensorPlatform(copy(platform_state),
                              platform_transition_model,
                              sensors=[copy(sonar)],
                              mounting_offsets=mounting_offsets,
                              mounting_mappings=mounting_mappings)
    platforms.append(copy(platform))

# Run Simulation
# ------------------------------------------------------------

# In[5]:

groundtruth_paths = set()  # Store for plotting later
platform_positions = []  # Store platform path
sensor_positions = []
sensor_orientations = []
for i in range(NUM_PLATFORMS):
    platform_positions.append([])
    sensor_positions.append([])
    sensor_orientations.append([])
measurement_sonar = []

# Simulate targets
for k in range(NUM_TARGETS):
    groundtruth_sim = gnd_simulators[k]

    # Create ground truth generator function
    gts = groundtruth_sim.groundtruth_paths_gen()

    timestamp = INIT_TIMESTAMP
    for i in range(NUM_SIM_STEPS):

        # Run Ground truth simulator
        next(gts)

        # Generate and extract ground truth state
        groundtruth_paths |= groundtruth_sim.groundtruth_paths

        timestamp = timestamp + STEP_DURATION

# Simulate detections
timestamp = INIT_TIMESTAMP
for i in range(NUM_SIM_STEPS):

    for j, platform in enumerate(platforms):

        detections = set()

        # Move platform
        platform.move(timestamp)

        # Store position and oritentation of platform/sensor(s)
        platform_positions[j].append(platform.state)
        sensor_positions[j].append(State(platform.sensors[0].position,
                                        timestamp))

        for path in groundtruth_paths:
            target_state = [state for state in path
                            if state.timestamp == timestamp][0]
            # Measure the target location
            detection = platform.sensors[0].gen_measurement(target_state)
            if detection is not None:
                detections.add(detection)

        detections |= platform.sensors[0].gen_clutter(timestamp)
        measurement_sonar.append((timestamp, detections))

    timestamp = timestamp + STEP_DURATION



###############################################################################
# Estimation                                                                  #
###############################################################################

# Estimate
timestamp = INIT_TIMESTAMP

# Assume we know the target's initial state
state_prior = copy(ground_truth_prior)

# Predictor & Updater
# ===================
predictor = UnscentedKalmanPredictor(target_transition_model)
updater = UnscentedKalmanUpdater(measurement_model=sonar.measurement_model)

# Hypothesiser & Data Associator
# ==============================
hypothesiser = DistanceHypothesiser(predictor, updater, Mahalanobis(), 20)
associator = GlobalNearestNeighbour(hypothesiser)

# Track Initiator
# ===============
state_vector = state_prior.state_vector
covar = CovarianceMatrix(np.diag([100. ** 2, 2. ** 2, 100. ** 2, 2. ** 2]))
prior_state = GaussianState(state_vector, covar)
initiator = SinglePointInitiator(prior_state, sonar.measurement_model)

# Track Deleter
# =============
deleter = UpdateTimeStepsDeleter(time_steps_since_update=10)

tracks = set()
i = 0
for timestamp, detections in measurement_sonar:

    if len(detections) == 0:
        continue

    # Perform data association
    associations = associator.associate(tracks, detections, timestamp)

    # Update tracks based on association hypotheses
    associated_detections = set()
    for track, hypothesis in associations.items():
        if hypothesis:
            state_post = updater.update(hypothesis)
            track.append(state_post)
            associated_detections.add(hypothesis.measurement)
        else:
            track.append(hypothesis.prediction)

    # Delete invalid tracks
    tracks -= deleter.delete_tracks(tracks)

    # Initiate new tracks
    unassociated_detections = detections - associated_detections
    tracks |= initiator.initiate(unassociated_detections)

    # Uncomment code below to plot all frames 
    # (WARNING: It takes a while and eats up RAM space!)
    plot_data(timestamp, groundtruth_paths, measurement_sonar, tracks,
              platform_positions, sensor_positions,
              sensor_orientations, sonar, i)
    i += 1

###############################################################################
# Metrics                                                                     #
###############################################################################
# track = tracks.pop()
cutoff_threshold = 1000
p = 2
gospa = GOSPAMetric(c=cutoff_threshold, p=p,
                  measurement_model_truth=LinearGaussian(4, [[0], [2]], None),
                  measurement_model_track=LinearGaussian(4, [[0], [2]], None))
ospa = OSPAMetric(c=cutoff_threshold, p=p,
                  measurement_model_truth=LinearGaussian(4, [[0], [2]], None),
                  measurement_model_track=LinearGaussian(4, [[0], [2]], None))
track_states = []
for track in tracks:
    states = []
    for i, state in enumerate(track.states):
        if i == 0:
            timestamp = state.timestamp
            states.append(state)
            continue
        if states[-1].timestamp == state.timestamp:
            states[-1] = state
        else:
            states.append(state)
    track_states += states

# track_states = [state for state in track.states for track in tracks]
gnd_track_states = [state for state in path.states
                    for path in groundtruth_paths]
ospa_metric = ospa.compute_over_time(track_states, gnd_track_states)
gospa_metric = gospa.compute_over_time(track_states, gnd_track_states)
plt.figure()
plt.plot([i for i in range(len(ospa_metric.value))],
         [value.value for value in ospa_metric.value])
plt.plot([i for i in range(len(gospa_metric.value))],
         [value.value['distance'] for value in gospa_metric.value])
plt.legend(['OSPA', 'GOSPA'])
plt.title("OSPA over time")
plt.show()

# ospa_cost_matrix = ospa.compute_cost_matrix(track.states, gnd_track.states)
# measured_to_truth, truth_to_measured = linear_sum_assignment(ospa_cost_matrix)
#
# truth_set = np.array([state.state_vector[[[0], [2]], [0]] for state in
#                       gnd_track.states])[:, :, 0].T
# track_set = np.array([state.state_vector[[[0], [2]], [0]] for state in
#                       track.states])[:, :, 0].T
# plt.figure()
# fig_b = plt.plot(track_set[0,:], track_set[1,:], 'bo-', truth_set[0,:],
#                  truth_set[1,:], 'r+-')
# truth_ind = truth_to_measured
# track_ind = measured_to_truth
# for ind in range(len(truth_ind)):
#     db = np.min([np.sqrt(sum(np.square(track_set[:,track_ind[ind]] - truth_set[:,truth_ind[ind]]))), ospa.c])
#     if db < cutoff_threshold:
#         plt.plot([track_set[0, track_ind[ind]], truth_set[0, truth_ind[ind]]],
#                  [track_set[1, track_ind[ind]], truth_set[1, truth_ind[ind]]],
#                  'k-')
#         plt.text(track_set[0, track_ind[ind]]/2.+truth_set[0, truth_ind[ind]]/2.,
#                  track_set[1, track_ind[ind]]/2.+truth_set[1, truth_ind[ind]]/2.,
#                  "{:.2f}".format(db),
#                  horizontalalignment='right',
#                  verticalalignment='bottom')
# # plt.title("OSPA Example [c={}, p={}, OSPA distance={:.2f}]".format(ospa.c, ospa.p, ospa_metric.value))
# plt.legend(['Track', 'Truth'])
plt.show()

# In[ ]:
